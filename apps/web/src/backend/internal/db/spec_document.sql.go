// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: spec_document.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAnalysisExists = `-- name: CheckAnalysisExists :one
SELECT EXISTS(
    SELECT 1 FROM analyses WHERE id = $1 AND status = 'completed'
) AS exists
`

func (q *Queries) CheckAnalysisExists(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAnalysisExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkCodebaseExists = `-- name: CheckCodebaseExists :one
SELECT EXISTS(
    SELECT 1 FROM codebases WHERE owner = $1 AND name = $2
) AS exists
`

type CheckCodebaseExistsParams struct {
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

// Checks if codebase exists by owner/name
func (q *Queries) CheckCodebaseExists(ctx context.Context, arg CheckCodebaseExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCodebaseExists, arg.Owner, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSpecDocumentExistsByLanguage = `-- name: CheckSpecDocumentExistsByLanguage :one
SELECT EXISTS(
    SELECT 1 FROM spec_documents WHERE analysis_id = $1 AND language = $2
) AS exists
`

type CheckSpecDocumentExistsByLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

func (q *Queries) CheckSpecDocumentExistsByLanguage(ctx context.Context, arg CheckSpecDocumentExistsByLanguageParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSpecDocumentExistsByLanguage, arg.AnalysisID, arg.Language)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAiSpecSummariesByCodebaseIDs = `-- name: GetAiSpecSummariesByCodebaseIDs :many
SELECT
    a.codebase_id,
    COUNT(DISTINCT sd.language) AS language_count,
    MAX(sd.created_at) AS latest_generated_at
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
WHERE a.codebase_id = ANY($1::uuid[])
  AND sd.user_id = $2
GROUP BY a.codebase_id
`

type GetAiSpecSummariesByCodebaseIDsParams struct {
	CodebaseIds []pgtype.UUID `json:"codebase_ids"`
	UserID      pgtype.UUID   `json:"user_id"`
}

type GetAiSpecSummariesByCodebaseIDsRow struct {
	CodebaseID        pgtype.UUID `json:"codebase_id"`
	LanguageCount     int64       `json:"language_count"`
	LatestGeneratedAt interface{} `json:"latest_generated_at"`
}

// Returns AI Spec summary aggregation for multiple codebase IDs
// Used for Dashboard RepositoryCard to show [AI Spec] badge
// Shows badge if user has ANY spec for the codebase, regardless of which analysis
func (q *Queries) GetAiSpecSummariesByCodebaseIDs(ctx context.Context, arg GetAiSpecSummariesByCodebaseIDsParams) ([]GetAiSpecSummariesByCodebaseIDsRow, error) {
	rows, err := q.db.Query(ctx, getAiSpecSummariesByCodebaseIDs, arg.CodebaseIds, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAiSpecSummariesByCodebaseIDsRow
	for rows.Next() {
		var i GetAiSpecSummariesByCodebaseIDsRow
		if err := rows.Scan(&i.CodebaseID, &i.LanguageCount, &i.LatestGeneratedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnalysisTestCount = `-- name: GetAnalysisTestCount :one
SELECT total_tests FROM analyses WHERE id = $1 AND status = 'completed'
`

// Returns the total test count for a completed analysis.
// Used for quota calculation before spec generation.
func (q *Queries) GetAnalysisTestCount(ctx context.Context, id pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getAnalysisTestCount, id)
	var total_tests int32
	err := row.Scan(&total_tests)
	return total_tests, err
}

const getAvailableLanguagesByAnalysisID = `-- name: GetAvailableLanguagesByAnalysisID :many
SELECT
    sd.language,
    sd.version AS latest_version,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
  AND sd.version = (
      SELECT MAX(sd2.version)
      FROM spec_documents sd2
      WHERE sd2.analysis_id = sd.analysis_id
        AND sd2.language = sd.language
  )
ORDER BY sd.language
`

type GetAvailableLanguagesByAnalysisIDRow struct {
	Language      string             `json:"language"`
	LatestVersion int32              `json:"latest_version"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

// Returns all available languages for an analysis with their latest version info (legacy - no user filter)
func (q *Queries) GetAvailableLanguagesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]GetAvailableLanguagesByAnalysisIDRow, error) {
	rows, err := q.db.Query(ctx, getAvailableLanguagesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableLanguagesByAnalysisIDRow
	for rows.Next() {
		var i GetAvailableLanguagesByAnalysisIDRow
		if err := rows.Scan(&i.Language, &i.LatestVersion, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableLanguagesByRepository = `-- name: GetAvailableLanguagesByRepository :many
SELECT
    sd.language,
    MAX(sd.version)::int AS latest_version,
    MAX(sd.created_at)::timestamptz AS latest_created_at
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
JOIN codebases c ON c.id = a.codebase_id
WHERE c.owner = $1 AND c.name = $2
  AND sd.user_id = $3
GROUP BY sd.language
ORDER BY sd.language
`

type GetAvailableLanguagesByRepositoryParams struct {
	Owner  string      `json:"owner"`
	Repo   string      `json:"repo"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetAvailableLanguagesByRepositoryRow struct {
	Language        string             `json:"language"`
	LatestVersion   int32              `json:"latest_version"`
	LatestCreatedAt pgtype.Timestamptz `json:"latest_created_at"`
}

// Returns all available languages for a repository with their latest version info
func (q *Queries) GetAvailableLanguagesByRepository(ctx context.Context, arg GetAvailableLanguagesByRepositoryParams) ([]GetAvailableLanguagesByRepositoryRow, error) {
	rows, err := q.db.Query(ctx, getAvailableLanguagesByRepository, arg.Owner, arg.Repo, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableLanguagesByRepositoryRow
	for rows.Next() {
		var i GetAvailableLanguagesByRepositoryRow
		if err := rows.Scan(&i.Language, &i.LatestVersion, &i.LatestCreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableLanguagesByUserAndAnalysis = `-- name: GetAvailableLanguagesByUserAndAnalysis :many
SELECT
    sd.language,
    sd.version AS latest_version,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
  AND sd.user_id = $2
  AND sd.version = (
      SELECT MAX(sd2.version)
      FROM spec_documents sd2
      WHERE sd2.analysis_id = sd.analysis_id
        AND sd2.user_id = sd.user_id
        AND sd2.language = sd.language
  )
ORDER BY sd.language
`

type GetAvailableLanguagesByUserAndAnalysisParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetAvailableLanguagesByUserAndAnalysisRow struct {
	Language      string             `json:"language"`
	LatestVersion int32              `json:"latest_version"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

// Returns all available languages for a specific user and analysis with their latest version info
func (q *Queries) GetAvailableLanguagesByUserAndAnalysis(ctx context.Context, arg GetAvailableLanguagesByUserAndAnalysisParams) ([]GetAvailableLanguagesByUserAndAnalysisRow, error) {
	rows, err := q.db.Query(ctx, getAvailableLanguagesByUserAndAnalysis, arg.AnalysisID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableLanguagesByUserAndAnalysisRow
	for rows.Next() {
		var i GetAvailableLanguagesByUserAndAnalysisRow
		if err := rows.Scan(&i.Language, &i.LatestVersion, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCachePredictionData = `-- name: GetCachePredictionData :one
WITH previous_spec AS (
    -- Get the most recent spec document for this codebase (different analysis) in the specified language
    SELECT spec_doc.id AS document_id, spec_doc.analysis_id
    FROM spec_documents spec_doc
    JOIN analyses a ON a.id = spec_doc.analysis_id
    WHERE a.codebase_id = (SELECT a2.codebase_id FROM analyses a2 WHERE a2.id = $1)
      AND spec_doc.user_id = $2
      AND spec_doc.language = $3
      AND spec_doc.analysis_id != $1
    ORDER BY spec_doc.created_at DESC
    LIMIT 1
),
previous_behaviors AS (
    -- Get all behaviors from previous spec with their source test info
    SELECT
        sb.id AS behavior_id,
        sb.original_name,
        tf.file_path
    FROM spec_behaviors sb
    JOIN spec_features sf ON sf.id = sb.feature_id
    JOIN spec_domains sdom ON sdom.id = sf.domain_id
    JOIN previous_spec ps ON ps.document_id = sdom.document_id
    LEFT JOIN test_cases tc ON tc.id = sb.source_test_case_id
    LEFT JOIN test_suites ts ON ts.id = tc.suite_id
    LEFT JOIN test_files tf ON tf.id = ts.file_id
),
current_tests AS (
    -- Get all test cases from current analysis with their file paths
    SELECT
        tc.name,
        tf.file_path
    FROM test_cases tc
    JOIN test_suites ts ON ts.id = tc.suite_id
    JOIN test_files tf ON tf.id = ts.file_id
    WHERE tf.analysis_id = $1
),
matched_behaviors AS (
    -- Count behaviors that have matching tests in current analysis
    SELECT COUNT(DISTINCT pb.behavior_id) AS count
    FROM previous_behaviors pb
    JOIN current_tests ct ON pb.original_name = ct.name AND pb.file_path = ct.file_path
    WHERE pb.file_path IS NOT NULL
)
SELECT
    COALESCE((SELECT COUNT(*) FROM previous_behaviors), 0)::int AS total_behaviors,
    COALESCE((SELECT count FROM matched_behaviors), 0)::int AS cacheable_behaviors
`

type GetCachePredictionDataParams struct {
	CurrentAnalysisID pgtype.UUID `json:"current_analysis_id"`
	UserID            pgtype.UUID `json:"user_id"`
	Language          string      `json:"language"`
}

type GetCachePredictionDataRow struct {
	TotalBehaviors     int32 `json:"total_behaviors"`
	CacheableBehaviors int32 `json:"cacheable_behaviors"`
}

// Returns cache prediction data by comparing current analysis test cases with previous spec behaviors
// Matches by test_case.name + test_file.file_path
// Returns total behaviors from previous spec and count of cacheable behaviors (those with matching tests)
func (q *Queries) GetCachePredictionData(ctx context.Context, arg GetCachePredictionDataParams) (GetCachePredictionDataRow, error) {
	row := q.db.QueryRow(ctx, getCachePredictionData, arg.CurrentAnalysisID, arg.UserID, arg.Language)
	var i GetCachePredictionDataRow
	err := row.Scan(&i.TotalBehaviors, &i.CacheableBehaviors)
	return i, err
}

const getCurrentAnalysisTestCount = `-- name: GetCurrentAnalysisTestCount :one
SELECT COUNT(*)::int AS total_tests
FROM test_cases tc
JOIN test_suites ts ON ts.id = tc.suite_id
JOIN test_files tf ON tf.id = ts.file_id
WHERE tf.analysis_id = $1
`

// Returns the total test count for the current analysis
func (q *Queries) GetCurrentAnalysisTestCount(ctx context.Context, analysisID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getCurrentAnalysisTestCount, analysisID)
	var total_tests int32
	err := row.Scan(&total_tests)
	return total_tests, err
}

const getLanguagesWithPreviousSpec = `-- name: GetLanguagesWithPreviousSpec :many
SELECT DISTINCT sd.language
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
WHERE a.codebase_id = (SELECT a2.codebase_id FROM analyses a2 WHERE a2.id = $1)
  AND sd.user_id = $2
  AND sd.analysis_id != $1
`

type GetLanguagesWithPreviousSpecParams struct {
	CurrentAnalysisID pgtype.UUID `json:"current_analysis_id"`
	UserID            pgtype.UUID `json:"user_id"`
}

// Returns all languages where user has a spec document for the same codebase but different analysis
// Batch version of HasPreviousSpecByLanguage to avoid N+1 queries
func (q *Queries) GetLanguagesWithPreviousSpec(ctx context.Context, arg GetLanguagesWithPreviousSpecParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getLanguagesWithPreviousSpec, arg.CurrentAnalysisID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecBehaviorSourceInfo = `-- name: GetSpecBehaviorSourceInfo :many
SELECT
    b.id AS behavior_id,
    tc.line_number,
    tc.status::text,
    tf.file_path,
    tf.framework
FROM spec_behaviors b
JOIN test_cases tc ON tc.id = b.source_test_case_id
JOIN test_suites ts ON ts.id = tc.suite_id
JOIN test_files tf ON tf.id = ts.file_id
WHERE b.id = ANY($1::uuid[])
`

type GetSpecBehaviorSourceInfoRow struct {
	BehaviorID pgtype.UUID `json:"behavior_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
	TcStatus   string      `json:"tc_status"`
	FilePath   string      `json:"file_path"`
	Framework  pgtype.Text `json:"framework"`
}

func (q *Queries) GetSpecBehaviorSourceInfo(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecBehaviorSourceInfoRow, error) {
	rows, err := q.db.Query(ctx, getSpecBehaviorSourceInfo, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecBehaviorSourceInfoRow
	for rows.Next() {
		var i GetSpecBehaviorSourceInfoRow
		if err := rows.Scan(
			&i.BehaviorID,
			&i.LineNumber,
			&i.TcStatus,
			&i.FilePath,
			&i.Framework,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecBehaviorsByFeatureIDs = `-- name: GetSpecBehaviorsByFeatureIDs :many
SELECT
    b.id,
    b.feature_id,
    b.original_name,
    b.converted_description,
    b.sort_order,
    b.source_test_case_id
FROM spec_behaviors b
WHERE b.feature_id = ANY($1::uuid[])
ORDER BY b.feature_id, b.sort_order
`

type GetSpecBehaviorsByFeatureIDsRow struct {
	ID                   pgtype.UUID `json:"id"`
	FeatureID            pgtype.UUID `json:"feature_id"`
	OriginalName         string      `json:"original_name"`
	ConvertedDescription string      `json:"converted_description"`
	SortOrder            int32       `json:"sort_order"`
	SourceTestCaseID     pgtype.UUID `json:"source_test_case_id"`
}

func (q *Queries) GetSpecBehaviorsByFeatureIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecBehaviorsByFeatureIDsRow, error) {
	rows, err := q.db.Query(ctx, getSpecBehaviorsByFeatureIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecBehaviorsByFeatureIDsRow
	for rows.Next() {
		var i GetSpecBehaviorsByFeatureIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.OriginalName,
			&i.ConvertedDescription,
			&i.SortOrder,
			&i.SourceTestCaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecDocumentByAnalysisID = `-- name: GetSpecDocumentByAnalysisID :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByAnalysisIDRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// (legacy - no user filter) Returns most recent spec document for an analysis
func (q *Queries) GetSpecDocumentByAnalysisID(ctx context.Context, analysisID pgtype.UUID) (GetSpecDocumentByAnalysisIDRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByAnalysisID, analysisID)
	var i GetSpecDocumentByAnalysisIDRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByAnalysisIDAndLanguage = `-- name: GetSpecDocumentByAnalysisIDAndLanguage :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByAnalysisIDAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

type GetSpecDocumentByAnalysisIDAndLanguageRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// (legacy - no user filter) Returns most recent spec document for an analysis and language
func (q *Queries) GetSpecDocumentByAnalysisIDAndLanguage(ctx context.Context, arg GetSpecDocumentByAnalysisIDAndLanguageParams) (GetSpecDocumentByAnalysisIDAndLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByAnalysisIDAndLanguage, arg.AnalysisID, arg.Language)
	var i GetSpecDocumentByAnalysisIDAndLanguageRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByRepository = `-- name: GetSpecDocumentByRepository :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at,
    a.commit_sha
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
JOIN codebases c ON c.id = a.codebase_id
WHERE c.owner = $1 AND c.name = $2
  AND sd.user_id = $3
  AND sd.language = $4
ORDER BY sd.created_at DESC, sd.version DESC
LIMIT 1
`

type GetSpecDocumentByRepositoryParams struct {
	Owner    string      `json:"owner"`
	Repo     string      `json:"repo"`
	UserID   pgtype.UUID `json:"user_id"`
	Language string      `json:"language"`
}

type GetSpecDocumentByRepositoryRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	CommitSha        string             `json:"commit_sha"`
}

// Returns latest spec document for a repository (owner/repo) via JOIN
// For repository-centric API that provides cross-analysis version access
func (q *Queries) GetSpecDocumentByRepository(ctx context.Context, arg GetSpecDocumentByRepositoryParams) (GetSpecDocumentByRepositoryRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByRepository,
		arg.Owner,
		arg.Repo,
		arg.UserID,
		arg.Language,
	)
	var i GetSpecDocumentByRepositoryRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
		&i.CommitSha,
	)
	return i, err
}

const getSpecDocumentByRepositoryAndDocumentId = `-- name: GetSpecDocumentByRepositoryAndDocumentId :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at,
    a.commit_sha
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
JOIN codebases c ON c.id = a.codebase_id
WHERE c.owner = $1 AND c.name = $2
  AND sd.user_id = $3
  AND sd.id = $4
`

type GetSpecDocumentByRepositoryAndDocumentIdParams struct {
	Owner      string      `json:"owner"`
	Repo       string      `json:"repo"`
	UserID     pgtype.UUID `json:"user_id"`
	DocumentID pgtype.UUID `json:"document_id"`
}

type GetSpecDocumentByRepositoryAndDocumentIdRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	CommitSha        string             `json:"commit_sha"`
}

// Returns specific spec document by document ID for a repository
func (q *Queries) GetSpecDocumentByRepositoryAndDocumentId(ctx context.Context, arg GetSpecDocumentByRepositoryAndDocumentIdParams) (GetSpecDocumentByRepositoryAndDocumentIdRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByRepositoryAndDocumentId,
		arg.Owner,
		arg.Repo,
		arg.UserID,
		arg.DocumentID,
	)
	var i GetSpecDocumentByRepositoryAndDocumentIdRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
		&i.CommitSha,
	)
	return i, err
}

const getSpecDocumentByRepositoryAndVersion = `-- name: GetSpecDocumentByRepositoryAndVersion :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at,
    a.commit_sha
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
JOIN codebases c ON c.id = a.codebase_id
WHERE c.owner = $1 AND c.name = $2
  AND sd.user_id = $3
  AND sd.language = $4
  AND sd.version = $5
`

type GetSpecDocumentByRepositoryAndVersionParams struct {
	Owner    string      `json:"owner"`
	Repo     string      `json:"repo"`
	UserID   pgtype.UUID `json:"user_id"`
	Language string      `json:"language"`
	Version  int32       `json:"version"`
}

type GetSpecDocumentByRepositoryAndVersionRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	CommitSha        string             `json:"commit_sha"`
}

// Returns specific version of spec document for a repository
func (q *Queries) GetSpecDocumentByRepositoryAndVersion(ctx context.Context, arg GetSpecDocumentByRepositoryAndVersionParams) (GetSpecDocumentByRepositoryAndVersionRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByRepositoryAndVersion,
		arg.Owner,
		arg.Repo,
		arg.UserID,
		arg.Language,
		arg.Version,
	)
	var i GetSpecDocumentByRepositoryAndVersionRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
		&i.CommitSha,
	)
	return i, err
}

const getSpecDocumentByUserAndAnalysis = `-- name: GetSpecDocumentByUserAndAnalysis :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByUserAndAnalysisParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetSpecDocumentByUserAndAnalysisRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns spec document for a specific user and analysis (for access control)
func (q *Queries) GetSpecDocumentByUserAndAnalysis(ctx context.Context, arg GetSpecDocumentByUserAndAnalysisParams) (GetSpecDocumentByUserAndAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByUserAndAnalysis, arg.AnalysisID, arg.UserID)
	var i GetSpecDocumentByUserAndAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByUserAndAnalysisAndLanguage = `-- name: GetSpecDocumentByUserAndAnalysisAndLanguage :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2 AND sd.language = $3
ORDER BY sd.version DESC
LIMIT 1
`

type GetSpecDocumentByUserAndAnalysisAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Language   string      `json:"language"`
}

type GetSpecDocumentByUserAndAnalysisAndLanguageRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns spec document for a specific user, analysis, and language (for access control)
func (q *Queries) GetSpecDocumentByUserAndAnalysisAndLanguage(ctx context.Context, arg GetSpecDocumentByUserAndAnalysisAndLanguageParams) (GetSpecDocumentByUserAndAnalysisAndLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByUserAndAnalysisAndLanguage, arg.AnalysisID, arg.UserID, arg.Language)
	var i GetSpecDocumentByUserAndAnalysisAndLanguageRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByUserAndVersion = `-- name: GetSpecDocumentByUserAndVersion :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2 AND sd.language = $3 AND sd.version = $4
`

type GetSpecDocumentByUserAndVersionParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Language   string      `json:"language"`
	Version    int32       `json:"version"`
}

type GetSpecDocumentByUserAndVersionRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns a specific version of a spec document for a specific user
func (q *Queries) GetSpecDocumentByUserAndVersion(ctx context.Context, arg GetSpecDocumentByUserAndVersionParams) (GetSpecDocumentByUserAndVersionRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByUserAndVersion,
		arg.AnalysisID,
		arg.UserID,
		arg.Language,
		arg.Version,
	)
	var i GetSpecDocumentByUserAndVersionRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDocumentByVersion = `-- name: GetSpecDocumentByVersion :one
SELECT
    sd.id,
    sd.analysis_id,
    sd.user_id,
    sd.language,
    sd.version,
    sd.executive_summary,
    sd.model_id,
    sd.created_at
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2 AND sd.version = $3
`

type GetSpecDocumentByVersionParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
	Version    int32       `json:"version"`
}

type GetSpecDocumentByVersionRow struct {
	ID               pgtype.UUID        `json:"id"`
	AnalysisID       pgtype.UUID        `json:"analysis_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	Language         string             `json:"language"`
	Version          int32              `json:"version"`
	ExecutiveSummary pgtype.Text        `json:"executive_summary"`
	ModelID          string             `json:"model_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Returns a specific version of a spec document (legacy - no user filter)
func (q *Queries) GetSpecDocumentByVersion(ctx context.Context, arg GetSpecDocumentByVersionParams) (GetSpecDocumentByVersionRow, error) {
	row := q.db.QueryRow(ctx, getSpecDocumentByVersion, arg.AnalysisID, arg.Language, arg.Version)
	var i GetSpecDocumentByVersionRow
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.UserID,
		&i.Language,
		&i.Version,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
	)
	return i, err
}

const getSpecDomainsByDocumentID = `-- name: GetSpecDomainsByDocumentID :many
SELECT
    d.id,
    d.name,
    d.description,
    d.sort_order,
    d.classification_confidence
FROM spec_domains d
WHERE d.document_id = $1
ORDER BY d.sort_order, d.name
`

type GetSpecDomainsByDocumentIDRow struct {
	ID                       pgtype.UUID    `json:"id"`
	Name                     string         `json:"name"`
	Description              pgtype.Text    `json:"description"`
	SortOrder                int32          `json:"sort_order"`
	ClassificationConfidence pgtype.Numeric `json:"classification_confidence"`
}

func (q *Queries) GetSpecDomainsByDocumentID(ctx context.Context, documentID pgtype.UUID) ([]GetSpecDomainsByDocumentIDRow, error) {
	rows, err := q.db.Query(ctx, getSpecDomainsByDocumentID, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecDomainsByDocumentIDRow
	for rows.Next() {
		var i GetSpecDomainsByDocumentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SortOrder,
			&i.ClassificationConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecFeaturesByDomainIDs = `-- name: GetSpecFeaturesByDomainIDs :many
SELECT
    f.id,
    f.domain_id,
    f.name,
    f.description,
    f.sort_order
FROM spec_features f
WHERE f.domain_id = ANY($1::uuid[])
ORDER BY f.domain_id, f.sort_order, f.name
`

type GetSpecFeaturesByDomainIDsRow struct {
	ID          pgtype.UUID `json:"id"`
	DomainID    pgtype.UUID `json:"domain_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	SortOrder   int32       `json:"sort_order"`
}

func (q *Queries) GetSpecFeaturesByDomainIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSpecFeaturesByDomainIDsRow, error) {
	rows, err := q.db.Query(ctx, getSpecFeaturesByDomainIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpecFeaturesByDomainIDsRow
	for rows.Next() {
		var i GetSpecFeaturesByDomainIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecGenerationStatus = `-- name: GetSpecGenerationStatus :one
SELECT
    rj.state,
    rj.created_at,
    rj.finalized_at,
    rj.errors
FROM river_job rj
WHERE rj.kind = 'specview:generate'
  AND rj.args->>'analysis_id' = $1
  AND rj.args->>'user_id' = $2
ORDER BY rj.created_at DESC
LIMIT 1
`

type GetSpecGenerationStatusParams struct {
	AnalysisID []byte `json:"analysis_id"`
	UserID     []byte `json:"user_id"`
}

type GetSpecGenerationStatusRow struct {
	State       RiverJobState      `json:"state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FinalizedAt pgtype.Timestamptz `json:"finalized_at"`
	Errors      [][]byte           `json:"errors"`
}

// Returns latest generation status for a specific user and analysis (any language)
func (q *Queries) GetSpecGenerationStatus(ctx context.Context, arg GetSpecGenerationStatusParams) (GetSpecGenerationStatusRow, error) {
	row := q.db.QueryRow(ctx, getSpecGenerationStatus, arg.AnalysisID, arg.UserID)
	var i GetSpecGenerationStatusRow
	err := row.Scan(
		&i.State,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Errors,
	)
	return i, err
}

const getSpecGenerationStatusByLanguage = `-- name: GetSpecGenerationStatusByLanguage :one
SELECT
    rj.state,
    rj.created_at,
    rj.finalized_at,
    rj.errors
FROM river_job rj
WHERE rj.kind = 'specview:generate'
  AND rj.args->>'analysis_id' = $1
  AND rj.args->>'user_id' = $2
  AND rj.args->>'language' = $3
ORDER BY rj.created_at DESC
LIMIT 1
`

type GetSpecGenerationStatusByLanguageParams struct {
	AnalysisID []byte `json:"analysis_id"`
	UserID     []byte `json:"user_id"`
	Language   []byte `json:"language"`
}

type GetSpecGenerationStatusByLanguageRow struct {
	State       RiverJobState      `json:"state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	FinalizedAt pgtype.Timestamptz `json:"finalized_at"`
	Errors      [][]byte           `json:"errors"`
}

// Returns generation status for a specific user, analysis, and language combination
func (q *Queries) GetSpecGenerationStatusByLanguage(ctx context.Context, arg GetSpecGenerationStatusByLanguageParams) (GetSpecGenerationStatusByLanguageRow, error) {
	row := q.db.QueryRow(ctx, getSpecGenerationStatusByLanguage, arg.AnalysisID, arg.UserID, arg.Language)
	var i GetSpecGenerationStatusByLanguageRow
	err := row.Scan(
		&i.State,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Errors,
	)
	return i, err
}

const getVersionHistoryByRepository = `-- name: GetVersionHistoryByRepository :many
SELECT
    sd.id,
    sd.analysis_id,
    sd.version,
    sd.language,
    sd.model_id,
    sd.created_at,
    a.commit_sha
FROM spec_documents sd
JOIN analyses a ON a.id = sd.analysis_id
JOIN codebases c ON c.id = a.codebase_id
WHERE c.owner = $1 AND c.name = $2
  AND sd.user_id = $3
  AND sd.language = $4
ORDER BY sd.created_at DESC
LIMIT 100
`

type GetVersionHistoryByRepositoryParams struct {
	Owner    string      `json:"owner"`
	Repo     string      `json:"repo"`
	UserID   pgtype.UUID `json:"user_id"`
	Language string      `json:"language"`
}

type GetVersionHistoryByRepositoryRow struct {
	ID         pgtype.UUID        `json:"id"`
	AnalysisID pgtype.UUID        `json:"analysis_id"`
	Version    int32              `json:"version"`
	Language   string             `json:"language"`
	ModelID    string             `json:"model_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	CommitSha  string             `json:"commit_sha"`
}

// Returns spec versions for a repository (across analyses) with commit SHA
// Ordered by creation date descending to show most recent first
// Limited to 100 versions to prevent unbounded result sets
func (q *Queries) GetVersionHistoryByRepository(ctx context.Context, arg GetVersionHistoryByRepositoryParams) ([]GetVersionHistoryByRepositoryRow, error) {
	rows, err := q.db.Query(ctx, getVersionHistoryByRepository,
		arg.Owner,
		arg.Repo,
		arg.UserID,
		arg.Language,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionHistoryByRepositoryRow
	for rows.Next() {
		var i GetVersionHistoryByRepositoryRow
		if err := rows.Scan(
			&i.ID,
			&i.AnalysisID,
			&i.Version,
			&i.Language,
			&i.ModelID,
			&i.CreatedAt,
			&i.CommitSha,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionsByLanguage = `-- name: GetVersionsByLanguage :many
SELECT
    sd.version,
    sd.created_at,
    sd.model_id
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.language = $2
ORDER BY sd.version DESC
`

type GetVersionsByLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

type GetVersionsByLanguageRow struct {
	Version   int32              `json:"version"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ModelID   string             `json:"model_id"`
}

// Returns all versions for a specific analysis and language, ordered by version descending (legacy - no user filter)
func (q *Queries) GetVersionsByLanguage(ctx context.Context, arg GetVersionsByLanguageParams) ([]GetVersionsByLanguageRow, error) {
	rows, err := q.db.Query(ctx, getVersionsByLanguage, arg.AnalysisID, arg.Language)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsByLanguageRow
	for rows.Next() {
		var i GetVersionsByLanguageRow
		if err := rows.Scan(&i.Version, &i.CreatedAt, &i.ModelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionsByUserAndLanguage = `-- name: GetVersionsByUserAndLanguage :many
SELECT
    sd.version,
    sd.created_at,
    sd.model_id
FROM spec_documents sd
WHERE sd.analysis_id = $1 AND sd.user_id = $2 AND sd.language = $3
ORDER BY sd.version DESC
`

type GetVersionsByUserAndLanguageParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	UserID     pgtype.UUID `json:"user_id"`
	Language   string      `json:"language"`
}

type GetVersionsByUserAndLanguageRow struct {
	Version   int32              `json:"version"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ModelID   string             `json:"model_id"`
}

// Returns all versions for a specific user, analysis and language, ordered by version descending
func (q *Queries) GetVersionsByUserAndLanguage(ctx context.Context, arg GetVersionsByUserAndLanguageParams) ([]GetVersionsByUserAndLanguageRow, error) {
	rows, err := q.db.Query(ctx, getVersionsByUserAndLanguage, arg.AnalysisID, arg.UserID, arg.Language)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsByUserAndLanguageRow
	for rows.Next() {
		var i GetVersionsByUserAndLanguageRow
		if err := rows.Scan(&i.Version, &i.CreatedAt, &i.ModelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPreviousSpecByLanguage = `-- name: HasPreviousSpecByLanguage :one
SELECT EXISTS(
    SELECT 1 FROM spec_documents sd
    JOIN analyses a ON a.id = sd.analysis_id
    WHERE a.codebase_id = (SELECT a2.codebase_id FROM analyses a2 WHERE a2.id = $1)
      AND sd.user_id = $2
      AND sd.language = $3
      AND sd.analysis_id != $1
) AS has_previous_spec
`

type HasPreviousSpecByLanguageParams struct {
	CurrentAnalysisID pgtype.UUID `json:"current_analysis_id"`
	UserID            pgtype.UUID `json:"user_id"`
	Language          string      `json:"language"`
}

// Checks if user has generated a spec document for the same codebase but different analysis
// Used to determine if behavior cache might exist for the selected language
func (q *Queries) HasPreviousSpecByLanguage(ctx context.Context, arg HasPreviousSpecByLanguageParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasPreviousSpecByLanguage, arg.CurrentAnalysisID, arg.UserID, arg.Language)
	var has_previous_spec bool
	err := row.Scan(&has_previous_spec)
	return has_previous_spec, err
}
