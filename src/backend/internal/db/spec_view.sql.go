// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: spec_view.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCodebaseCache = `-- name: DeleteCodebaseCache :exec
DELETE FROM spec_view_cache
WHERE codebase_id = $1
`

func (q *Queries) DeleteCodebaseCache(ctx context.Context, codebaseID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCodebaseCache, codebaseID)
	return err
}

const getCachedConversions = `-- name: GetCachedConversions :many
SELECT
    id,
    cache_key_hash,
    codebase_id,
    file_path,
    framework,
    suite_hierarchy,
    original_name,
    converted_name,
    language,
    model_id,
    created_at
FROM spec_view_cache
WHERE cache_key_hash = ANY($1::bytea[])
  AND model_id = $2
`

type GetCachedConversionsParams struct {
	Column1 [][]byte `json:"column_1"`
	ModelID string   `json:"model_id"`
}

func (q *Queries) GetCachedConversions(ctx context.Context, arg GetCachedConversionsParams) ([]SpecViewCache, error) {
	rows, err := q.db.Query(ctx, getCachedConversions, arg.Column1, arg.ModelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpecViewCache
	for rows.Next() {
		var i SpecViewCache
		if err := rows.Scan(
			&i.ID,
			&i.CacheKeyHash,
			&i.CodebaseID,
			&i.FilePath,
			&i.Framework,
			&i.SuiteHierarchy,
			&i.OriginalName,
			&i.ConvertedName,
			&i.Language,
			&i.ModelID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCachedConversion = `-- name: UpsertCachedConversion :exec
INSERT INTO spec_view_cache (
    cache_key_hash,
    codebase_id,
    file_path,
    framework,
    suite_hierarchy,
    original_name,
    converted_name,
    language,
    model_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (cache_key_hash, model_id) DO UPDATE SET
    converted_name = EXCLUDED.converted_name,
    codebase_id = EXCLUDED.codebase_id,
    file_path = EXCLUDED.file_path,
    framework = EXCLUDED.framework,
    suite_hierarchy = EXCLUDED.suite_hierarchy,
    original_name = EXCLUDED.original_name,
    language = EXCLUDED.language
`

type UpsertCachedConversionParams struct {
	CacheKeyHash   []byte      `json:"cache_key_hash"`
	CodebaseID     pgtype.UUID `json:"codebase_id"`
	FilePath       string      `json:"file_path"`
	Framework      string      `json:"framework"`
	SuiteHierarchy string      `json:"suite_hierarchy"`
	OriginalName   string      `json:"original_name"`
	ConvertedName  string      `json:"converted_name"`
	Language       string      `json:"language"`
	ModelID        string      `json:"model_id"`
}

func (q *Queries) UpsertCachedConversion(ctx context.Context, arg UpsertCachedConversionParams) error {
	_, err := q.db.Exec(ctx, upsertCachedConversion,
		arg.CacheKeyHash,
		arg.CodebaseID,
		arg.FilePath,
		arg.Framework,
		arg.SuiteHierarchy,
		arg.OriginalName,
		arg.ConvertedName,
		arg.Language,
		arg.ModelID,
	)
	return err
}
