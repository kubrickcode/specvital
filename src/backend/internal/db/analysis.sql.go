// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: analysis.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPendingAnalysis = `-- name: CreatePendingAnalysis :one
INSERT INTO analyses (codebase_id, commit_sha, status)
VALUES ($1, $2, 'pending')
RETURNING id
`

type CreatePendingAnalysisParams struct {
	CodebaseID pgtype.UUID `json:"codebase_id"`
	CommitSha  string      `json:"commit_sha"`
}

func (q *Queries) CreatePendingAnalysis(ctx context.Context, arg CreatePendingAnalysisParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPendingAnalysis, arg.CodebaseID, arg.CommitSha)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAnalysisStatus = `-- name: GetAnalysisStatus :one
SELECT
    a.id,
    a.status,
    a.error_message,
    a.created_at,
    a.completed_at
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
ORDER BY a.created_at DESC
LIMIT 1
`

type GetAnalysisStatusParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetAnalysisStatusRow struct {
	ID           pgtype.UUID        `json:"id"`
	Status       AnalysisStatus     `json:"status"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetAnalysisStatus(ctx context.Context, arg GetAnalysisStatusParams) (GetAnalysisStatusRow, error) {
	row := q.db.QueryRow(ctx, getAnalysisStatus, arg.Host, arg.Owner, arg.Name)
	var i GetAnalysisStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCodebaseIDByOwnerRepo = `-- name: GetCodebaseIDByOwnerRepo :one
SELECT id
FROM codebases
WHERE host = $1 AND owner = $2 AND name = $3 AND is_stale = false
`

type GetCodebaseIDByOwnerRepoParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) GetCodebaseIDByOwnerRepo(ctx context.Context, arg GetCodebaseIDByOwnerRepoParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getCodebaseIDByOwnerRepo, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getLatestCompletedAnalysis = `-- name: GetLatestCompletedAnalysis :one
SELECT
    a.id,
    a.commit_sha,
    a.branch_name,
    a.committed_at,
    a.completed_at,
    a.total_suites,
    a.total_tests,
    c.owner,
    c.name as repo
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
  AND a.status = 'completed'
ORDER BY a.created_at DESC
LIMIT 1
`

type GetLatestCompletedAnalysisParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetLatestCompletedAnalysisRow struct {
	ID          pgtype.UUID        `json:"id"`
	CommitSha   string             `json:"commit_sha"`
	BranchName  pgtype.Text        `json:"branch_name"`
	CommittedAt pgtype.Timestamptz `json:"committed_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	Owner       string             `json:"owner"`
	Repo        string             `json:"repo"`
}

func (q *Queries) GetLatestCompletedAnalysis(ctx context.Context, arg GetLatestCompletedAnalysisParams) (GetLatestCompletedAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getLatestCompletedAnalysis, arg.Host, arg.Owner, arg.Name)
	var i GetLatestCompletedAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.CommitSha,
		&i.BranchName,
		&i.CommittedAt,
		&i.CompletedAt,
		&i.TotalSuites,
		&i.TotalTests,
		&i.Owner,
		&i.Repo,
	)
	return i, err
}

const getPaginatedRepositoriesByName = `-- name: GetPaginatedRepositoriesByName :many
SELECT
    c.id AS codebase_id,
    c.owner,
    c.name,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at AS analyzed_at,
    a.total_tests,
    EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ) AS is_analyzed_by_me
FROM codebases c
JOIN LATERAL (
    SELECT id, commit_sha, completed_at, total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE c.last_viewed_at IS NOT NULL
  AND c.is_stale = false
  AND (
    $2::text = 'all'
    OR ($2::text = 'my' AND EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ))
    OR ($2::text = 'community' AND NOT EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ))
  )
  AND (
    $3::text IS NULL
    OR (
      ($4::text = 'asc' AND (c.name, c.id) > ($3::text, $5::uuid))
      OR ($4::text = 'desc' AND (c.name, c.id) < ($3::text, $5::uuid))
    )
  )
ORDER BY
  CASE WHEN $4::text = 'asc' THEN c.name END ASC,
  CASE WHEN $4::text = 'desc' THEN c.name END DESC,
  CASE WHEN $4::text = 'asc' THEN c.id END ASC,
  CASE WHEN $4::text = 'desc' THEN c.id END DESC
LIMIT $6
`

type GetPaginatedRepositoriesByNameParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	ViewFilter string      `json:"view_filter"`
	CursorName string      `json:"cursor_name"`
	SortOrder  string      `json:"sort_order"`
	CursorID   pgtype.UUID `json:"cursor_id"`
	PageLimit  int32       `json:"page_limit"`
}

type GetPaginatedRepositoriesByNameRow struct {
	CodebaseID     pgtype.UUID        `json:"codebase_id"`
	Owner          string             `json:"owner"`
	Name           string             `json:"name"`
	AnalysisID     pgtype.UUID        `json:"analysis_id"`
	CommitSha      string             `json:"commit_sha"`
	AnalyzedAt     pgtype.Timestamptz `json:"analyzed_at"`
	TotalTests     int32              `json:"total_tests"`
	IsAnalyzedByMe bool               `json:"is_analyzed_by_me"`
}

func (q *Queries) GetPaginatedRepositoriesByName(ctx context.Context, arg GetPaginatedRepositoriesByNameParams) ([]GetPaginatedRepositoriesByNameRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedRepositoriesByName,
		arg.UserID,
		arg.ViewFilter,
		arg.CursorName,
		arg.SortOrder,
		arg.CursorID,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedRepositoriesByNameRow
	for rows.Next() {
		var i GetPaginatedRepositoriesByNameRow
		if err := rows.Scan(
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.AnalysisID,
			&i.CommitSha,
			&i.AnalyzedAt,
			&i.TotalTests,
			&i.IsAnalyzedByMe,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedRepositoriesByRecent = `-- name: GetPaginatedRepositoriesByRecent :many
SELECT
    c.id AS codebase_id,
    c.owner,
    c.name,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at AS analyzed_at,
    a.total_tests,
    EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ) AS is_analyzed_by_me
FROM codebases c
JOIN LATERAL (
    SELECT id, commit_sha, completed_at, total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE c.last_viewed_at IS NOT NULL
  AND c.is_stale = false
  AND (
    $2::text = 'all'
    OR ($2::text = 'my' AND EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ))
    OR ($2::text = 'community' AND NOT EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ))
  )
  AND (
    $3::timestamptz IS NULL
    OR (
      ($4::text = 'desc' AND (a.completed_at, c.id) < ($3::timestamptz, $5::uuid))
      OR ($4::text = 'asc' AND (a.completed_at, c.id) > ($3::timestamptz, $5::uuid))
    )
  )
ORDER BY
  CASE WHEN $4::text = 'desc' THEN a.completed_at END DESC,
  CASE WHEN $4::text = 'asc' THEN a.completed_at END ASC,
  CASE WHEN $4::text = 'desc' THEN c.id END DESC,
  CASE WHEN $4::text = 'asc' THEN c.id END ASC
LIMIT $6
`

type GetPaginatedRepositoriesByRecentParams struct {
	UserID           pgtype.UUID        `json:"user_id"`
	ViewFilter       string             `json:"view_filter"`
	CursorAnalyzedAt pgtype.Timestamptz `json:"cursor_analyzed_at"`
	SortOrder        string             `json:"sort_order"`
	CursorID         pgtype.UUID        `json:"cursor_id"`
	PageLimit        int32              `json:"page_limit"`
}

type GetPaginatedRepositoriesByRecentRow struct {
	CodebaseID     pgtype.UUID        `json:"codebase_id"`
	Owner          string             `json:"owner"`
	Name           string             `json:"name"`
	AnalysisID     pgtype.UUID        `json:"analysis_id"`
	CommitSha      string             `json:"commit_sha"`
	AnalyzedAt     pgtype.Timestamptz `json:"analyzed_at"`
	TotalTests     int32              `json:"total_tests"`
	IsAnalyzedByMe bool               `json:"is_analyzed_by_me"`
}

func (q *Queries) GetPaginatedRepositoriesByRecent(ctx context.Context, arg GetPaginatedRepositoriesByRecentParams) ([]GetPaginatedRepositoriesByRecentRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedRepositoriesByRecent,
		arg.UserID,
		arg.ViewFilter,
		arg.CursorAnalyzedAt,
		arg.SortOrder,
		arg.CursorID,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedRepositoriesByRecentRow
	for rows.Next() {
		var i GetPaginatedRepositoriesByRecentRow
		if err := rows.Scan(
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.AnalysisID,
			&i.CommitSha,
			&i.AnalyzedAt,
			&i.TotalTests,
			&i.IsAnalyzedByMe,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedRepositoriesByTests = `-- name: GetPaginatedRepositoriesByTests :many
SELECT
    c.id AS codebase_id,
    c.owner,
    c.name,
    a.id AS analysis_id,
    a.commit_sha,
    a.completed_at AS analyzed_at,
    a.total_tests,
    EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ) AS is_analyzed_by_me
FROM codebases c
JOIN LATERAL (
    SELECT id, commit_sha, completed_at, total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE c.last_viewed_at IS NOT NULL
  AND c.is_stale = false
  AND (
    $2::text = 'all'
    OR ($2::text = 'my' AND EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ))
    OR ($2::text = 'community' AND NOT EXISTS(
        SELECT 1 FROM user_analysis_history uah
        WHERE uah.analysis_id = a.id AND uah.user_id = $1::uuid
    ))
  )
  AND (
    $3::int IS NULL
    OR (
      ($4::text = 'desc' AND (a.total_tests, c.id) < ($3::int, $5::uuid))
      OR ($4::text = 'asc' AND (a.total_tests, c.id) > ($3::int, $5::uuid))
    )
  )
ORDER BY
  CASE WHEN $4::text = 'desc' THEN a.total_tests END DESC,
  CASE WHEN $4::text = 'asc' THEN a.total_tests END ASC,
  CASE WHEN $4::text = 'desc' THEN c.id END DESC,
  CASE WHEN $4::text = 'asc' THEN c.id END ASC
LIMIT $6
`

type GetPaginatedRepositoriesByTestsParams struct {
	UserID          pgtype.UUID `json:"user_id"`
	ViewFilter      string      `json:"view_filter"`
	CursorTestCount int32       `json:"cursor_test_count"`
	SortOrder       string      `json:"sort_order"`
	CursorID        pgtype.UUID `json:"cursor_id"`
	PageLimit       int32       `json:"page_limit"`
}

type GetPaginatedRepositoriesByTestsRow struct {
	CodebaseID     pgtype.UUID        `json:"codebase_id"`
	Owner          string             `json:"owner"`
	Name           string             `json:"name"`
	AnalysisID     pgtype.UUID        `json:"analysis_id"`
	CommitSha      string             `json:"commit_sha"`
	AnalyzedAt     pgtype.Timestamptz `json:"analyzed_at"`
	TotalTests     int32              `json:"total_tests"`
	IsAnalyzedByMe bool               `json:"is_analyzed_by_me"`
}

func (q *Queries) GetPaginatedRepositoriesByTests(ctx context.Context, arg GetPaginatedRepositoriesByTestsParams) ([]GetPaginatedRepositoriesByTestsRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedRepositoriesByTests,
		arg.UserID,
		arg.ViewFilter,
		arg.CursorTestCount,
		arg.SortOrder,
		arg.CursorID,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedRepositoriesByTestsRow
	for rows.Next() {
		var i GetPaginatedRepositoriesByTestsRow
		if err := rows.Scan(
			&i.CodebaseID,
			&i.Owner,
			&i.Name,
			&i.AnalysisID,
			&i.CommitSha,
			&i.AnalyzedAt,
			&i.TotalTests,
			&i.IsAnalyzedByMe,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviousAnalysis = `-- name: GetPreviousAnalysis :one
SELECT
    id,
    commit_sha,
    completed_at,
    total_tests
FROM analyses
WHERE codebase_id = $1
  AND status = 'completed'
  AND id != $2
ORDER BY created_at DESC
LIMIT 1
`

type GetPreviousAnalysisParams struct {
	CodebaseID pgtype.UUID `json:"codebase_id"`
	ID         pgtype.UUID `json:"id"`
}

type GetPreviousAnalysisRow struct {
	ID          pgtype.UUID        `json:"id"`
	CommitSha   string             `json:"commit_sha"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	TotalTests  int32              `json:"total_tests"`
}

func (q *Queries) GetPreviousAnalysis(ctx context.Context, arg GetPreviousAnalysisParams) (GetPreviousAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getPreviousAnalysis, arg.CodebaseID, arg.ID)
	var i GetPreviousAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.CommitSha,
		&i.CompletedAt,
		&i.TotalTests,
	)
	return i, err
}

const getRepositoryStats = `-- name: GetRepositoryStats :one
SELECT
    COUNT(DISTINCT c.id) AS total_repositories,
    COALESCE(SUM(a.total_tests), 0)::bigint AS total_tests
FROM codebases c
LEFT JOIN LATERAL (
    SELECT total_tests
    FROM analyses
    WHERE codebase_id = c.id AND status = 'completed'
    ORDER BY created_at DESC
    LIMIT 1
) a ON true
WHERE c.last_viewed_at IS NOT NULL AND c.is_stale = false
`

type GetRepositoryStatsRow struct {
	TotalRepositories int64 `json:"total_repositories"`
	TotalTests        int64 `json:"total_tests"`
}

func (q *Queries) GetRepositoryStats(ctx context.Context) (GetRepositoryStatsRow, error) {
	row := q.db.QueryRow(ctx, getRepositoryStats)
	var i GetRepositoryStatsRow
	err := row.Scan(&i.TotalRepositories, &i.TotalTests)
	return i, err
}

const getTestCasesBySuiteIDs = `-- name: GetTestCasesBySuiteIDs :many
SELECT
    tc.id,
    tc.suite_id,
    tc.name,
    tc.line_number,
    tc.status
FROM test_cases tc
WHERE tc.suite_id = ANY($1::uuid[])
ORDER BY tc.suite_id, tc.line_number
`

type GetTestCasesBySuiteIDsRow struct {
	ID         pgtype.UUID `json:"id"`
	SuiteID    pgtype.UUID `json:"suite_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Status     TestStatus  `json:"status"`
}

func (q *Queries) GetTestCasesBySuiteIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetTestCasesBySuiteIDsRow, error) {
	rows, err := q.db.Query(ctx, getTestCasesBySuiteIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesBySuiteIDsRow
	for rows.Next() {
		var i GetTestCasesBySuiteIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.Name,
			&i.LineNumber,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSuitesByAnalysisID = `-- name: GetTestSuitesByAnalysisID :many
SELECT
    ts.id,
    ts.file_path,
    ts.framework,
    ts.name
FROM test_suites ts
WHERE ts.analysis_id = $1
ORDER BY ts.file_path, ts.depth, ts.line_number
`

type GetTestSuitesByAnalysisIDRow struct {
	ID        pgtype.UUID `json:"id"`
	FilePath  string      `json:"file_path"`
	Framework pgtype.Text `json:"framework"`
	Name      string      `json:"name"`
}

func (q *Queries) GetTestSuitesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]GetTestSuitesByAnalysisIDRow, error) {
	rows, err := q.db.Query(ctx, getTestSuitesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestSuitesByAnalysisIDRow
	for rows.Next() {
		var i GetTestSuitesByAnalysisIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FilePath,
			&i.Framework,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAnalysisFailed = `-- name: MarkAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2
WHERE id = $1
`

type MarkAnalysisFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) MarkAnalysisFailed(ctx context.Context, arg MarkAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, markAnalysisFailed, arg.ID, arg.ErrorMessage)
	return err
}

const updateCodebaseLastViewed = `-- name: UpdateCodebaseLastViewed :exec
UPDATE codebases
SET last_viewed_at = now()
WHERE host = $1 AND owner = $2 AND name = $3
`

type UpdateCodebaseLastViewedParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) UpdateCodebaseLastViewed(ctx context.Context, arg UpdateCodebaseLastViewedParams) error {
	_, err := q.db.Exec(ctx, updateCodebaseLastViewed, arg.Host, arg.Owner, arg.Name)
	return err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name)
VALUES ($1, $2, $3)
ON CONFLICT (host, owner, name) DO UPDATE SET updated_at = now()
RETURNING id
`

type UpsertCodebaseParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertCodebase, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
