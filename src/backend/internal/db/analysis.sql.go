// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analysis.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPendingAnalysis = `-- name: CreatePendingAnalysis :one
INSERT INTO analyses (codebase_id, commit_sha, status)
VALUES ($1, '', 'pending')
RETURNING id
`

func (q *Queries) CreatePendingAnalysis(ctx context.Context, codebaseID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPendingAnalysis, codebaseID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAnalysisStatus = `-- name: GetAnalysisStatus :one
SELECT
    a.id,
    a.status,
    a.error_message,
    a.created_at,
    a.completed_at
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
ORDER BY a.created_at DESC
LIMIT 1
`

type GetAnalysisStatusParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetAnalysisStatusRow struct {
	ID           pgtype.UUID        `json:"id"`
	Status       AnalysisStatus     `json:"status"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetAnalysisStatus(ctx context.Context, arg GetAnalysisStatusParams) (GetAnalysisStatusRow, error) {
	row := q.db.QueryRow(ctx, getAnalysisStatus, arg.Host, arg.Owner, arg.Name)
	var i GetAnalysisStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getLatestCompletedAnalysis = `-- name: GetLatestCompletedAnalysis :one
SELECT
    a.id,
    a.commit_sha,
    a.completed_at,
    a.total_suites,
    a.total_tests,
    c.owner,
    c.name as repo
FROM analyses a
JOIN codebases c ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3
  AND a.status = 'completed'
ORDER BY a.created_at DESC
LIMIT 1
`

type GetLatestCompletedAnalysisParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type GetLatestCompletedAnalysisRow struct {
	ID          pgtype.UUID        `json:"id"`
	CommitSha   string             `json:"commit_sha"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	Owner       string             `json:"owner"`
	Repo        string             `json:"repo"`
}

func (q *Queries) GetLatestCompletedAnalysis(ctx context.Context, arg GetLatestCompletedAnalysisParams) (GetLatestCompletedAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getLatestCompletedAnalysis, arg.Host, arg.Owner, arg.Name)
	var i GetLatestCompletedAnalysisRow
	err := row.Scan(
		&i.ID,
		&i.CommitSha,
		&i.CompletedAt,
		&i.TotalSuites,
		&i.TotalTests,
		&i.Owner,
		&i.Repo,
	)
	return i, err
}

const markAnalysisFailed = `-- name: MarkAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2
WHERE id = $1
`

type MarkAnalysisFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) MarkAnalysisFailed(ctx context.Context, arg MarkAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, markAnalysisFailed, arg.ID, arg.ErrorMessage)
	return err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name)
VALUES ($1, $2, $3)
ON CONFLICT (host, owner, name) DO UPDATE SET updated_at = now()
RETURNING id
`

type UpsertCodebaseParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertCodebase, arg.Host, arg.Owner, arg.Name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
